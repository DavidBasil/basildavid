---
layout: default
title: Django Online Store Tutorial, part 1
description: Learn how to build a Django online store, part 1
excerpt: Django Online Store, part 1
---

<div class="well">
  <h4>Index</h4>
  <ol>
    <li><a href="#start">Start a Project</a></li>
    <li><a href="#models">Store Models</a></li>
    <li><a href="#views">Store Views</a></li>
  </ol>
</div>

<p>In previous tutorials we learnt how to build a basic blog application with Django so now lets step up and create something more a little bit more complex. E-commerce has been a very popular theme for the last decade because online sales have been growing immensely and an ability to build online store is a hot skill to have.</p>

<p>Even though online store's application architercture differs from that of a blog's one, the main principles stay the same: create database models, take care of logic in views, map urls to those views and build templates so the front-end user can interact with out models. We are going to use a Paypal system to take care of the payments.</p>

<hr />

<p id="start">In your projects folder create a new directory: I'm going to call it "basilstore". You can name it however you like but make sure it makes sense to you. Inside the newly created dir (shorthand for directory) install a virtual environment so we can isolate our project from global packages:
<pre><code class="bash">virtualenv -p python3 venv</code></pre>
Activate the environment and install Django(version 1.10):
<pre><code class="bash">pip install django==1.10</code></pre>
Now start a project called "basilstore":
<pre>
<code class="bash">django-admin startporject basilstore</code></pre>
Start an app <mark>"store"</mark> and put its name to INSTALLED_APP settings:
<pre><code class="bash">python manage.py startapp store</code></pre>
<pre>
<code class="python">INSTALLED_APPS = {
	'store'
	...
}
</code></pre>
</p>

<hr />

<p id="models">Our store is going to have categories and products that are organized into those different categories. Create a "category" and "product" models in <mark>"store/models.py"</mark>:
<pre>
<code class="python">from django.db import models
from django.core.urlresolvers import reverse


class Category(models.Model):
    name = models.CharField(max_length=160)
    slug = models.SlugField(max_length=160, unique=True)

    class Meta:
        ordering = ('name',)
        verbose_name = 'category'
        verbose_name_plural = 'categories'

    def __str__(self):
        return self.name      

class Product(models.Model):
    name = models.CharField(max_length=160)
    slug = models.SlugField(max_length=160) 
    image = models.ImageField(upload_to='products_media', blank=True)
    description = models.TextField(blank=True)
    price = models.DecimalField(max_digits=8, decimal_places=2)
    stock = models.PositiveIntegerField()
    available = models.BooleanField(default=True)
    created = models.DateTimeField(auto_now_add=True)
    updated = models.DateTimeField(auto_now=True)
    category = models.ForeignKey(Category, related_name='products')

    class Meta:
        ordering = ('name',)
        index_together = (('id', 'slug'),)

    def __str__(self):
        return self.name
</code></pre>
In the product class we set a "one-to-many" relationship between a product and a category: each category can have many products but each product can belong to only one category.
We also let Django index "id" and "slug" together in order to impove querying performance.
</p>

<p>Our product model has an image field so we need a "pillow" package:
<pre>
<code class="bash">pip install pillow
</code></pre>
Since we played with models it's time to make migrations and sync the database:
<pre>
<code class="python">python manage.py makemigrations</code></pre>
<pre><code class="bash">python manage.py migrate</code></pre>
</p>

<p>Edit <mark>"admin.py"</mark> to add our models to the admin site so we can manage them from admin panel:
<pre>
<code>from django.contrib import admin
from .models import Category, Product

class CategoryAdmin(admin.ModelAdmin):
    list_display = ['name', 'slug']
    prepopulated_fields = {'slug': ('name',)}


class ProductAdmin(admin.ModelAdmin):
    list_display = ['name', 'slug', 'price', 'stock', 'available', 
                    'created', 'updated']
    list_filter = ['available', 'created', 'updated']
    list_editable = ['price', 'stock', 'available']
    prepopulated_fields = {'slug': ('name',)}

admin.site.register(Category, CategoryAdmin)
admin.site.register(Product, ProductAdmin)
</code></pre>
As you can remember from the blog tutorial, the "prepopulated_fields" option automatically sets slug name while we type the name of the category. 
</p>

<p>We registered models into the admin site, what's next? Create a superuser, right? Run:
<pre>
<code class="bash">python manage.py createsuperuser
</code></pre>
I usually set "admin" for username and "pass123" for password during the development. Always pick more complex credentials for live projects though.
</p>

<!-- TODO: check categories and products -->

<p>Now run the server, go to the admin site and add a couple categories, lets say "books" and "clothing".</p>

<hr />

<p id="views">It's time to build the logic of our app, aka "views". We are going to take care of product list first. Edit <mark>"store/views.py"</mark>:
<pre>
<code>from django.shortcuts import render, get_object_or_404
from .models import Category, Product


def product_list(request, category_slug=None):
    category = None
    categories = Category.objects.all()
    products = Product.objects.filter(available=True)
    if category_slug:
        category = get_object_or_404(Category, slug=category_slug)
        products = products.filter(category=category)
    return render(request, 'store/product/list.html', {'category': category,
                                                    'categories': categories,
                                                    'products': products})
</code></pre>
If the url supplies with category slug then django filters the results according to that particular category. Otherwise it will just output a list of all available products. And as with the blog post we need a view for each individual product:
<pre>
<code>
def product_detail(request, id, slug):
    product = get_object_or_404(Product, id=id, slug=slug, available=True)
		return render(request, 'store/product/detail.html', {'product': product})
</code>
</pre>
</p>

<p>Next step involves urls. Create a file "urls.py" in "store" directory:
<pre>
<code class="python">
from django.conf.urls import url
from . import views


urlpatterns = [
    url(r'^$', views.product_list, name='product_list'),
    url(r'^(?P<category_slug>[-\w]+)/$', views.product_list,
                                        name='product_list_by_category'),
    url(r'^(?P<id>\d+)/(?P<slug>[-\w]+)/$', views.product_detail,
                                            name='product_detail')
]
</code></pre>
Notice that we mapped two distinct urls to one view - "product_list". The first one lists all products if url does not supply with a category parameter and the second one filters products according to the given category.
</p>

<p>You probably want to jump staight to templates (the fun part) at this moment but we need to edit the main "urls.py" file to include "store" app's urls. And before that add "get_absolute_url" methods to our models. "models.py":
<pre>
<code class="python">
from django.core.urlsresolvers import reverse
...

class Category(models.Model):
	...
	def get_absolute_url(self):
		return reverse('store:product_list_by_category', args=[self.slug])

class Product(models.Model):
	...
	def get_absolute_url(self):
		return reverse('store:product_detail', arg=[self.id, self.slug])
</code>
</pre>
"urls.py":
<pre>
<code>
from django.conf.urls import url, include
from django.contrib import admin

urlpatterns = [
	url(r'^', include('store.urls', namespace='store')),
	url(r'^admin/', include(admin.site.urls)),
]
</code></pre>
</p>

<p>We got close to the fun part: templates. Create the following stucture in the "store" app:
<ul>
	<li>templates/</li>
	<li>&nbsp;&nbsp;store/</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;base.html</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;product/</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.html</li>
	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;detail.html</li>
</ul>
Note that both base.html file and product folder are children of the store directory.
</p>

<p>Fill out "base.html":
<pre>
<code class="html">
{% raw %}
{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;meta charset=&quot;utf-8&quot; /&gt;
	&lt;title&gt;{% block title %}My shop{% endblock %}&lt;/title&gt;
	&lt;link href=&quot;{% static &quot;css/base.css&quot; %}&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
 &lt;div id=&quot;header&quot;&gt;
   &lt;a href=&quot;/&quot; class=&quot;logo&quot;&gt;My shop&lt;/a&gt;
 &lt;/div&gt;

 &lt;div id=&quot;subheader&quot;&gt;
   &lt;div class=&quot;cart&quot;&gt;Your cart is empty.&lt;/div&gt;
 &lt;/div&gt;

 &lt;div id=&quot;content&quot;&gt;
  {% block content %}
  {% endblock %}
 &lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
{% endraw %}
</code></pre>
We don't touch on static files in this tutorial. I am going to dedicate whole other post on how to work with css/js within the Django project.
</p>

<p>Edit "store/product/list.html":
<pre><code>{% raw %}
{% extends 'store/base.html' %}
{% load static %}

{% block title %}
{% if category %} {{ category.name }} {% else %}Products {% endif %}
{% endblock %}

{% block content %}
&lt;!-- sidebar --&gt;
&lt;div class=&quot;sidebar&quot;&gt;
  &lt;h4&gt;Categories&lt;/h4&gt;
  &lt;ul&gt;
    &lt;li {% if not category %}class=&quot;selected&quot;{% endif %}&gt;
      &lt;a href=&quot;{% url 'store:product_list' %}&quot;&gt;All&lt;/a&gt;
    &lt;/li&gt;
    {% for c in categories %}
    &lt;li {% if category.slug == c.slug %}class=&quot;selected&quot;{% endif %}&gt;
      &lt;a href=&quot;{{ c.get_absolute.url }}&quot;&gt;{{ c.name }}&lt;/a&gt;
    &lt;/li&gt;
    {% endfor %}
  &lt;/ul&gt;
&lt;/div&gt;

&lt;!-- main --&gt;
&lt;div id=&quot;main&quot; class=&quot;product-list&quot;&gt;
  &lt;h2&gt;{% if category %} {{ category.name }} {% else %}Products{% endif %}&lt;/h2&gt;
  {% for product in products %}
  &lt;div class=&quot;item&quot;&gt;
    &lt;a href=&quot;{{ product.get_absolute_url }}&quot;&gt;
      &lt;img src=&quot;{% if product.image %}{{ product.image.url }}{% else %}{% static 'img/no_image.png' %}{% endif %}&quot;&gt;
    &lt;/a&gt;
    &lt;a href=&quot;{{ product.get_absolute_url }}&quot;&gt;{{ product.name }} | ${{ product.price }} &lt;/a&gt;
  &lt;/div&gt;
  {% endfor %}
&lt;/div&gt;


{% endblock %}
{% endraw %}
</code>
</pre>
This template serves both views: it either displays either all products or filters according to the category parameter.
</p>

<!-- TODO: media urls in settings.py and urls.py -->

<p>Start the server and add severl products to either category.</p>

<p>Our application needs a detail view for each product. Add the following code to "store/product/detail.html":
<pre>
<code>{% raw %}
{% extends 'store/base.html' %}
{% load static %}

{% block title %}
{% if category %} {{ category.name }} {% else %}Products {% endif %}
{% endblock %}

{% block content %}

&lt;div class=&quot;product-detail&quot;&gt;
 &lt;!-- image --&gt;
 &lt;img src=&quot;{% if product.image %} {{ product.image.url }} {% else %} {% static 'img/no_image.png' %} {% endif %}&quot;&gt;
 &lt;!-- name --&gt;
 &lt;h2&gt;{{ product.name }}&lt;/h2&gt;
 &lt;!-- category --&gt;
 &lt;h4&gt;
   Category: &lt;a href=&quot;{{ product.category.get_absolute_url }}&quot;&gt; {{ product.category }}&lt;/a&gt;
 &lt;/h4&gt;
 &lt;!-- price --&gt;
 &lt;p class=&quot;price&quot;&gt;${{ product.price }}&lt;/p&gt;
 &lt;!-- description --&gt;
 &lt;p class=&quot;description&quot;&gt;{{ product.description }}&lt;/p&gt;
&lt;/div&gt;

{% endblock %}
{% endraw %}
</code></pre>
</p>

<hr />

<p>You probably noticed that we did not do anything different from the blog's tutorial so far. You're right; the main diffrentianing feature of online store is a shopping cart. Shopping cart allows users to pick the products they plan to buy by saving the items in a so-called "session". (<a href="https://docs.djangoproject.com/en/1.10/topics/http/sessions/">more on django sessions</a>).A user can then continue looking around the store until he/she decides to make the purchase. </p>

<p>Edit "settings.py":
<pre>
<code>
CART_SESSION_ID = 'cart'
</code></pre>
This piece of code enables our application to keep the same session for each individual user.
</p>

<p>Shopping cart requires its own app; run:
<pre>
<code class="bash">
python manage.py startapp cart
</code></pre>
Add cart to "INSTALLED_APPS".
</p>

<p>Inside the cart app create a new file named "cart.py":
<pre><code>
from decimal import Decimal
from django.conf import settings
from store.models import Product


class Cart(object):
    def __init__(self, request):
        self.session = request.session
        cart = self.session.get(settings.CART_SESSION_ID)
        if not cart:
            cart = self.session[settings.CART_SESSION_ID] = {}
        self.cart = cart
</code></pre>
The code may seem confusing to you from the start but in reality its dead simple. If there is not cart, we initialize it with the empty dictionary; in other words we create am empty cart. And if there is a cart we retrieve from the current session. Thats it, nothing magical here.
</p>

<p>Ok, we have a cart class, now we need logic that allows to add products to it. To be more techical, we need a method that populates the empty cart list with keys and values (products and their corresponding prices). And also a save method to save the cart after the user added products. Add these two methods to the Cart class:
<pre>
<code class="python">
    def add(self, product, quantity=1, update_quantity=False):
        product_id = str(product.id)
        if product_id not in self.cart:
            self.cart[product_id] = {'quantity': 0, 'price': str(product.price)}
        if update_quantity:
            self.cart[product_id]['quantity'] = quantity
        else:
            self.cart[product_id]['quantity'] += quantity
        self.save()

    def save(self):
        self.session[settings.CART_SESSION_ID] = self.cart
        self.session.modified = True
</code>
</pre>
The "quantity=1" parameters means that the default quantity of the product to add is one. "update_quantity" either updates the given number of products or adds new quantity to the existing one. 
</p>

<p>What is the user changes his mind and wants to remove some or all items from the cart? For that we define the "remove" method:
<pre>
<code> def remove(self, product):
        product_id = str(product.id)
        if product_id in self.cart:
            del self.cart[product_id]
            self.save()
</code></pre>
</p>

<p>Next we need to perform a so-called "iteration". We add the "__iter__" method to our Cart class:
<pre>
<code>
    def __iter__(self):
        product_ids = self.cart.keys()
        products = Product.objects.filter(id__in=product_ids)
        for product in products:
            self.cart[str(product.id)]['product'] = product
        for item in self.cart.values():
            item['price'] = Decimal(item['price'])
            item['total_price'] = item['price'] * item['quantity']
            yield item
</code></pre>
</p>

<p>When you do online shopping you probably notice that shopping cart always shows the total number of items that are present in the cart. For that add a "__len__" method to "cart.py":
<pre>
<code>
    def __len__(self):
        return sum(item['quantity'] for item in self.cart.values())
</code></pre>
And let's also calculate the total cost of the shopping cart:
<pre>
<code>
    def get_total_price(self):
        return sum(Decimal(item['price']) * item['quantity'] for item in self.cart.values())
</code></pre>
Finally we need a way to clear up the cart after the order is done:
<pre>
<code>
    def clear(self):
        del self.session[settings.CART_SESSION_ID]
        self.session.modified = True
</code></pre>
</p>

<p>Our final "cart.py" should look like this:
<pre>
<code>
from decimal import Decimal
from django.conf import settings
from store.models import Product


class Cart(object):

    def __init__(self, request):
        self.session = request.session
        cart = self.session.get(settings.CART_SESSION_ID)
        if not cart:
            cart = self.session[settings.CART_SESSION_ID] = {}
        self.cart = cart

    def add(self, product, quantity=1, update_quantity=False):
        product_id = str(product.id)
        if product_id not in self.cart:
            self.cart[product_id] = {'quantity': 0, 'price': str(product.price)}
        if update_quantity:
            self.cart[product_id]['quantity'] = quantity
        else:
            self.cart[product_id]['quantity'] += quantity
        self.save()

    def save(self):
        self.session[settings.CART_SESSION_ID] = self.cart
        self.session.modified = True

    def remove(self, product):
        product_id = str(product.id)
        if product_id in self.cart:
            del self.cart[product_id]
            self.save()

    def __iter__(self):
        product_ids = self.cart.keys()
        products = Product.objects.filter(id__in=product_ids)
        for product in products:
            self.cart[str(product.id)]['product'] = product
        for item in self.cart.values():
            item['price'] = Decimal(item['price'])
            item['total_price'] = item['price'] * item['quantity']
            yield item

    def __len__(self):
        return sum(item['quantity'] for item in self.cart.values())

    def get_total_price(self):
        return sum(Decimal(item['price']) * item['quantity'] for item in self.cart.values())

    def clear(self):
        del self.session[settings.CART_SESSION_ID]
        self.session.modified = True
</code></pre>
</p>

<hr />

<p>Its time for add views for the cart app. User nedd to somehow add the items to his shopping cart, right? For that we need forms. Create "forms.py" inside the cart applicaton:
<pre>
<code>
from django import forms

PRODUCT_QUANTITY_CHOICES = [(i, str(i)) for i in range(1, 11)]

class CartAddProductForm(forms.Form):
    quantity = forms.TypedChoiceField(choices=PRODUCT_QUANTITY_CHOICES,
                                        coerce=int)
    update = forms.BooleanField(required=False,
                                initial=False,
                                widget=forms.HiddenInput)
</code></pre>
The buyer can add the items to the cart with the quantity of up to 10. Update fields indicate whether the chosen quanitity should be added to the existing number or the current number should be updated with the given quantity. For the form to work we need to program a view. Add the following lines to "cart/views.py":
<pre>
<code>
from django.shortcuts import render, redirect, get_object_or_404
from django.views.decorators.http import require_POST
from store.models import Product
from .cart import Cart
from .forms import CartAddProductForm

@require_POST
def cart_add(request, product_id):
    cart = Cart(request)
    product = get_object_or_404(Product, id=product_id)
    form = CartAddProductForm(request.POST)
    if form.is_valid():
        cd = form.cleaned_data
        cart.add(product=product,
                quantity=cd['quantity'],
                update_quantity=cd['update'])
    return redirect('cart:cart_detail')
</code></pre>
We import "require_POST" decorator to use with "cart_add" function. "card_add" method checks for form validity: if the form is valid a new product is added to the cart (or updates the quantity). The method also redirects the user to the cart_detail template.
Let's add another method for the opposite action:
<pre>
<code>
def cart_remove(request, product_id):
    cart = Cart(request)
    product = get_object_or_404(Product, id=product_id)
    cart.remove(product)
    return redirect('cart:cart_detail')
</code>
</pre>
We have add and remove methods; lastly we create a "card_detail" view:
<pre>
<code>
def cart_detail(request):
    cart = Cart(request)
    for item in cart:
        item['update_quantity_form'] = CartAddProductForm(
                initial={'quantity': item['quantity'], 'update': True} 
                )
    return render(request, 'cart/detail.html', {'cart': cart})
</code></pre>
</p>

<hr />

<p>Almost every app should have a "urls.py". The "app" directory does not have it yet so lets create one:
<pre>
<code>
from django.conf.urls import url
from . import views


urlpatterns = [
    url(r'^$', views.cart_detail, name='cart_detail'),
    url(r'^add/(?P<product_id>\d+)/$', views.cart_add, name='cart_add'),
    url(r'^remove/(?P<product_id>\d+)/$', views.cart_remove, name='cart_remove'),
]
</code></pre>
Also edit the main "urls.py" file:
<pre>
<code>
urlspatterns = [
  ...
  url(r'cart/', include('cart.urls', namespace='cart')),
  ...	
]
</code></pre>
</p>
