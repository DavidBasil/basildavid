---
layout: default
title: Django Blog tutorial, part 3
description: Learn how to build a Django blog application, part 3
excerpt: Comments, Tags
---

<div class="well">
  <h4>Index</h4>
  <ol>
    <li><a href="#comments">Comments</a></li>
    <li><a href="#tags">Tags</a></li>
  </ol>
</div>

<p>Welcome back to "Django Blog" tutorial. In this section we'll go through creating commenting and tagging functionality for our blog.</p>

<p id="comments">We need to store comments in the database, right? For that we'll create a Comment model. Edit <mark>models.py</mark>:
<pre><code class="python">
class Comment(models.Model):
    post = models.ForeignKey(Post, related_name='comments')
    name = models.CharField(max_length=80)
    email = models.EmailField()
    body = models.TextField()
    created = models.DateTimeField(auto_now_add=True)
    updated = models.DateTimeField(auto_now=True)
    active = models.BooleanField(default=True)

    class Meta:
        ordering = ('created',)

    def __str__(self):
        return 'Comment by {} on {}'.format(self.name, self.post)
</code></pre>
Each post can have multiple comments but each comment can be associated with only one post. 
<p>Name: name of the comment's author. </p>
<p>Email: author's email. </p>
<p>Body: comment's text. </p>
<p>active: we use this boolean to deactivate/activate comments in admin site.</p>
</p>

<p>Run:
<pre><code class="bash">python manage.py makemigrations</code></pre>
to create a new migration file that reflects the current state of blog's models.
</p>

<p>Django created a migration file called <mark>0002_comment.py</mark>.
Run: 
<pre><code class="bash">python manage.py migrate</code></pre>
to apply the migration.
</p>

<p>After we applied migrations to the database, go ahead and register our newly created model to the admin site. <br>
<mark>admin.py</mark>:
<pre><code class="python">
from .models import Post, Comment

admin.site.register(Comment)
</code></pre>
We are able to manage all blog comments from now on.
</p>

<hr>

<p>Question: how can users make comments for a particular blog post? We are going to create a form for that functionality.</p>

<p>Since we need to build a form out of the existing model, we'll use Django's class "ModelForm".</p>

<p>Make a new file in blog directory called <mark>forms.py</mark>:</p>

<p><pre><code class="python">
from django import forms
from .models import Comment


class CommentForm(forms.ModelForm):
  class Meta:
    model = Comment
    fields = ('name', 'email', 'body')
</code></pre>
Django analyses the class which is defined in Meta class and automatically builds the corresponding form for us. "Fields" determine the form fields we want.</p>

<hr>

<p>Edit <mark>views.py</mark>:
<pre><code class="python">
def post_detail(request, year, month, day, post):
    post = get_object_or_404(Post, slug=post,
                                    publish__year=year,
                                    publish__month=month,
                                    publish__day=day)
    comments = post.comments.filter(active=True)
    if request.method == 'POST':
        comment_form = CommentForm(data=request.POST)
        if comment_form.is_valid():
            new_comment = comment_form.save(commit=False)
            new_comment.post = post
            new_comment.save()
            comment_form = CommentForm()
    else:
        comment_form = CommentForm()
    return render(request, 'blog/post/detail.html', {'post': post,
                                                'comments': comments,
                                                'comment_form': comment_form})
</code></pre>
We extract all comments associated with the current post. If http request is GET then we just display the empty form for the user. If request method is POST, we perform the following logic: <br>
1. We create a new comment submittes via the form but don't save to the database yet. <br>
2. We associate the new comment with the current post. <br>
3. Lastly, the new comment is saved to the database. <br>
</p>

<hr>

<p>Edit <mark>"detail.html"</mark>template to show post's comments and the comment form:
<pre><code class="html">
{% raw %}
{% with comments.count as total_comments %}
&lt;h3&gt;{{ total_comments }} comment{{ total_comments|pluralize }}&lt;/h3&gt;
{% endwith %}

{% for comment in comments %}
  &lt;div class=&quot;comment&quot;&gt;
    &lt;span class=&quot;info&quot;&gt;
      Comment {{ forloop.counter }} by {{ comment.name }} {{ comment.created }}
    &lt;/span&gt;
    {{ comment.body|linebreaks }}
  &lt;/div&gt;
{% empty %}
  &lt;p&gt;There are no comments.&lt;/p&gt;
{% endfor %}

{% if new_comment %}
  &lt;h3&gt;The comment has been added.&lt;/h3&gt;
{% else %}
  &lt;h3&gt;Add a new comment:&lt;/h3&gt;
  &lt;form action=&quot;&quot; method=&quot;POST&quot;&gt;
    {% csrf_token %}
    {{ comment_form.as_p }}
    &lt;input type=&quot;submit&quot; value=&quot;Add&quot;&gt;
  &lt;/form&gt;
{% endif %}
{% endraw %}
</code></pre>
{% raw %}"{% with %}"{% endraw %} tag lets us assign a specific value to a new variable; we do so to avoid acessing database multiple times (a bad practice). "Pluralize" filter displays a plural suffix for the word which it succeedes. And we iterate through comments displaying each one of them.
</p>

<p>If the comment has been added a success message is dispayed; an empty form is rendered if otherwise.</p>

<p>We can deactivate, edit or delete comments via the admin site.</p>

<hr>

<p id="tags">Next, we are going to create a tagging functionality for our blog. We could build it ourselves but why bother when we could plug ready-to-use application created by other developer. For this tutorial we use <a href="https://django-taggit.readthedocs.io/en/latest/">"django-taggit"</a> app.
Run: <pre><code class="bash">pip install django-taggit</code></pre>
Add "taggit" to installed apps in <mark>settings.py</mark>:<br><br>
<pre><code class="python">
INSTALLED_APPS = [
    'blog',
    'taggit',
</code></pre>
Edit <mark>models.py</mark>:
<pre><code class="python">
from taggit.managers import TaggableManager

class Post(models.Model):
  ...
  tags = TaggableManager()  
</code></pre>
<p>Sync the database:</p>
<pre><code class="bash">
python manage.py makemigrations

python manage.py migrate
</code></pre>
Now the tagging system is available in admin site. Let's add "health" and "fitness" tags to our first post.
</p>

<p>In order to display post's tags we edit <mark>list.html</mark> template (insert the following code after post title):
<pre><code class="html">{% raw %}
&lt;p class=&quot;tags&quot;&gt;Tags: {{ post.tags.all|join:&quot;, &quot; }}&lt;/p&gt;{% endraw %}
</code></pre>
Run server, go to the blog link and there you can see that every post has a list of tags.
</p>

<p>Question: what is the main purpose of tags? To group posts, right? Edit <mark>views.py</mark>:
<pre><code class="python">
def post_list(request, tag_slug=None):
    posts = Post.objects.all()
    tag = None
    if tag_slug:
        tag = get_object_or_404(Tag, slug=tag_slug)
        posts = posts.filter(tags__in=[tag])
    return render(request, 'blog/post/list.html', {'posts': posts,
                                                    'tag': tag})  
</code></pre>
The "post_list" function will filter posts according to the tag if a tag_url is present in url.
</p>

<p>Modify <mark>"urls.py"</mark>:
<pre><code class="python">
urlspatterns = [
  ...
  url(r'^tag/(?P<tag_slug>[-\w]+)/$', views.post_list, 
        name='post_list_by_tag'),
]
</code></pre>
Both urls are mapped to the same view function but the second one calls the view with the tag slug and lists posts according to the mentioned tag.
</p>

<p>Add this code to <mark>"list.html"</mark>:
<pre><code class="html">{% raw %}
{% if tag %}
  &lt;h3&gt;Posts tagged with &quot;{{ tag.name }}&quot;&lt;/h3&gt;
{% endif %}

&lt;span class=&quot;tags&quot;&gt;Tags: 
{% for tag in post.tags.all %} 
&lt;a href=&quot;{% url &quot;blog:post_list_by_tag&quot; tag.slug %}&quot;&gt;{{ tag.name }}&lt;/a&gt;
{% if not forloop.last %}, {% endif %}
{% endfor %}
&lt;/span&gt;

{% endraw %}
</code></pre>
Now the user will see the list of posts filtered by the tag.
</p>






